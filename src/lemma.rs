
pub struct EditRule<'a> {
    instructions: Vec<EditInstruction<'a>>
}

pub enum EditInstruction<'a> {
    Remove(&'a str),
    Add(&'a str),
    Keep(&'a str),
    KeepLength(usize)
}


impl<'a> EditRule<'a> {
    pub fn from_str(editrule: &'a str) -> Self {
        let mut instructions: Vec<EditInstruction<'a>> = Vec::new();
        let mut mode: char = ' ';
        let mut begin = 0;
        for (i, c) in editrule.char_indices() {
            if mode != ' ' {
                if begin > 0 && c == ']' {
                    instructions.push(match mode {
                        '+' => EditInstruction::Add(&editrule[begin..i]),
                        '-' => EditInstruction::Remove(&editrule[begin..i]),
                        '=' => {
                            let ss = &editrule[begin..i];
                            if ss.chars().nth(0) == Some('#') && ss[1..].parse::<usize>().is_ok() {
                                EditInstruction::KeepLength(ss[1..].parse::<usize>().unwrap())
                            } else {
                                EditInstruction::Keep(ss)
                            }
                        },
                        _ => panic!("Parsing editrule failed (invalid mode), should not happen!")
                    });
                    //reset
                    begin = 0;
                    mode = ' ';
                }
                if c == '[' {
                    begin = i+1;
                }
            }
            if c == '+' || c == '-' || c == '=' {
                mode = c;
            }
        }
        EditRule {
            instructions: instructions
        }
    }
}

///applies the edit rule (as generated by sesdiff) to convert a word from into its lemma
fn get_lemma(word: &str, editrule: &str) -> String {
    let editrule = EditRule::from_str(editrule);
    let mut lemma = String::new();
    //TODO
    lemma
}

